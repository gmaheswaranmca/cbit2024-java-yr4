Questions on searching and sorting:
### [Find Peak Element](https://leetcode.com/problems/find-peak-element/)
**Problem Statement:**
A peak element is an element that is strictly greater than its neighbors. 
Given a 0-indexed integer array `nums`, find a peak element, and return its index. 
If the array contains multiple peaks, return the index to any of the peaks.

**Solution Approach:**
- **Binary Search:** 
Use binary search to find a peak element by comparing the middle element to its neighbors. 
This approach has a time complexity of O(log n).

### [Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)
**Problem Statement:**
Write an efficient algorithm that searches for a value in an `m x n` matrix. 
This matrix has the following properties:
  - Integers in each row are sorted from left to right.
  - The first integer of each row is greater than the last integer of the previous row.

**Solution Approach:**
- **Binary Search:** 
Treat the matrix as a flat sorted array and use binary search. 
Convert the 1D index to 2D indices during the search. 
This approach has a time complexity of O(log(m*n)).

### [Sort Colors]
(https://leetcode.com/problems/sort-colors/)
**Problem Statement:**
Given an array `nums` with `n` objects colored red, white, or blue, sort them in-place 
so that objects of the same color are adjacent, 
with the colors in the order red, white, and blue. 
We use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.

**Solution Approach:**
- **One-pass Dutch National Flag algorithm:** 
Use three pointers to sort the array in a single pass. 
This approach has a time complexity of O(n).


### [Kth Largest Element in an Array]
(https://leetcode.com/problems/kth-largest-element-in-an-array/)
**Problem Statement:**
Given an integer array `nums` and an integer `k`, 
return the `k`th largest element in the array.

**Solution Approach:**
- **Quickselect Algorithm:** 
Use the quickselect algorithm, 
which is similar to quicksort but only partially sorts the array 
to find the kth largest element. 
This approach has an average time complexity of O(n).



LeetCode - Binary Tree questions:

1. Inorder Traversal
**Problem:** [Binary Tree Inorder Traversal]
(https://leetcode.com/problems/binary-tree-inorder-traversal/)
(https://www.hackerrank.com/challenges/tree-inorder-traversal/problem)

2. Preorder Traversal
**Problem:** [Binary Tree Preorder Traversal]
(https://leetcode.com/problems/binary-tree-preorder-traversal/)
(https://www.hackerrank.com/challenges/tree-preorder-traversal/problem)

3. Postorder Traversal
**Problem:** [Binary Tree Postorder Traversal]
(https://leetcode.com/problems/binary-tree-postorder-traversal/)
(https://www.hackerrank.com/challenges/tree-postorder-traversal/problem)

4. Level Order Traversal
**Problem:** [Binary Tree Level Order Traversal]
(https://leetcode.com/problems/binary-tree-level-order-traversal/)
(https://www.codechef.com/problems/BINTREE)


#### **Maximum Depth of Binary Tree (LeetCode 104)**
https://leetcode.com/problems/maximum-depth-of-binary-tree/

   - **Problem:** Given a binary tree, find its maximum depth.
   - **Solution:** Use a depth-first search (DFS) or 
            breadth-first search (BFS) 
            to traverse the tree and keep track of the maximum depth encountered.
   - **Example:**
     ```python
     class Solution:
         def maxDepth(self, root: TreeNode) -> int:
             if not root:
                 return 0
             left_depth = self.maxDepth(root.left)
             right_depth = self.maxDepth(root.right)
             return max(left_depth, right_depth) + 1
     ```

#### **Symmetric Tree (LeetCode 101)**
   https://leetcode.com/problems/symmetric-tree/description/     
   - **Problem:** Check if a binary tree is symmetric around its center.
   - **Solution:** Use a recursive function to check 
        if the left and right subtrees are mirror images of each other.
   - **Example:**
     ```python
     class Solution:
         def isSymmetric(self, root: TreeNode) -> bool:
             def is_mirror(left, right):
                 if not left and not right:
                     return True
                 if not left or not right:
                     return False
                 return (left.val == right.val) and is_mirror(left.left, right.right) and is_mirror(left.right, right.left)
             
             return is_mirror(root, root)
     ```

#### **Invert Binary Tree (LeetCode 226)**
    https://leetcode.com/problems/invert-binary-tree/
   - **Problem:** Invert a binary tree.
   - **Solution:** Swap the left and right children of each node in the tree.
   - **Example:**
     ```python
     class Solution:
         def invertTree(self, root: TreeNode) -> TreeNode:
             if root:
                 root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)
             return root
     ```

#### **Path Sum (LeetCode 112)**
    https://leetcode.com/problems/path-sum/
   - **Problem:** Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
   - **Solution:** Use DFS to check each path's sum from the root to the leaves.
   - **Example:**
     ```python
     class Solution:
         def hasPathSum(self, root: TreeNode, sum: int) -> bool:
             if not root:
                 return False
             if not root.left and not root.right:
                 return root.val == sum
             sum -= root.val
             return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)
     ```

#### **Same Tree (LeetCode 100)**
    https://leetcode.com/problems/same-tree/
   - **Problem:** Given two binary trees, write a function to check if they are the same or not.
   - **Solution:** Compare each node in both trees to see if they have the same structure and values.
   - **Example:**
     ```python
     class Solution:
         def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
             if not p and not q:
                 return True
             if not p or not q:
                 return False
             if p.val != q.val:
                 return False
             return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
     ```









Breadth-First Search (BFS) Problems:
    Number of Islands: 
        This problem involves counting the number of distinct islands in a 2D grid map. 
        We can solve it using BFS. 
        Problem Link
        https://leetcode.com/problems/number-of-islands/
    Word Ladder: 
        Find the length of the shortest transformation sequence 
        from a start word to an end word, using BFS. 
        Problem Link
        https://leetcode.com/problems/word-ladder/

Depth-First Search (DFS) Problems:
    Number of Islands: 
        Count the number of islands in a 2D grid map, utilizing DFS. 
        Problem Link
        https://leetcode.com/problems/number-of-islands/
    Word Search: 
        Determine if a word exists in a 2D board, using DFS. 
        Problem Link
        https://leetcode.com/problems/word-search/